<!doctype html>
<html>
  <head>
    <title>Rocks</title>
    <meta charset="utf-8">
  </head>
  <body>
    <div>
      <div>
        <button id="build" type="button">Build</button>
        <button id="play" type="button">Play</button>
      </div>
      <canvas id="board" width="640" height="640"></canvas>
      <div id="gameState"></div>
      <div id="builder">
        <div>
          <label for="widthInput">Width</label>
          <input id="widthInput" type="number" min="1" max="64" value="10">
        </div>
        <div>
          <label for="heightInput">Height</label>
          <input id="heightInput" type="number" min="1" max="64" value="10">
        </div>
        <div>
          <select id="selectedTile">
            <option value="0" selected>Empty</option>
            <option value="1">Wall</option>
            <option value="2">Collectable</option>
            <option value="3">Rock</option>
            <option value="4">Dirt</option>
            <option value="5">Player</option>
          </select>
        </div>
        <div>
          <output id="generatedBoard"></output>
        </div>
        <div>
          <textarea id="loadedBoard" cols="80"></textarea>
          <button id="loadBoard" type="button">Load</button>
        </div>
      </div>
    </div>
  </body>
  <script type="module">
    const tickMs = 250;
    const tileSize = 20;
    const tiles = new Image();

    const tileNames = {
      EMPTY: 0,
      WALL: 1,
      COLLECTABLE: 2,
      ROCK: 3,
      DIRT: 4,
      PLAYER: 5,
      DEAD_PLAYER: 6,
    };

    function drawTile(context, tile, x, y, width, height) {
      context.save();

      context.drawImage(
        tiles,
        0,
        tiles.naturalWidth * tile,
        tiles.naturalWidth,
        tiles.naturalWidth,
        x,
        y,
        width,
        height
      );

      context.restore();
    }

    function renderBoard(canvas, board, originalBoard) {
      const context = canvas.getContext("2d");

      const tileWidth = canvas.width / board.width;
      const tileHeight = canvas.height / board.height;

      const areBoardsCompatible =
        board.width === originalBoard?.width &&
        board.height === originalBoard?.height;

      board.tiles.forEach((tile, index) => {
        if (areBoardsCompatible && tile === originalBoard.tiles[index]) {
          return;
        }

        const tileX = index % board.width;
        const tileY = Math.floor(index / board.width);

        drawTile(context, tile, tileX * tileWidth, tileY * tileHeight, tileWidth, tileHeight);
      });
    }

    function newBoard(width, height) {
      return {
        width,
        height,
        tiles: Array(width * height).fill(tileNames.EMPTY, 0),
      };
    }

    function isInBounds(board, x, y) {
      return x >= 0 && x < board.width && y >= 0 && y < board.height;
    }

    function validateCoordinate(board, x, y) {
      if (!isInBounds(board, x, y)) {
        throw new Error("Coordinate out of bounds");
      }
    }

    function getTile(board, x, y) {
      validateCoordinate(board, x, y);
      return board.tiles[x + y * board.width];
    }

    function setTile(board, x, y, tile) {
      validateCoordinate(board, x, y);
      board.tiles[x + y * board.width] = tile;
    }

    function cloneBoard(board) {
      return {
        width: board.width,
        height: board.height,
        tiles: board.tiles.slice(),
      };
    }

    function newGameState(board) {
      return {
        board: cloneBoard(board),
        collected: 0,
        fallingRocks: [],
      };
    }

    const tileBits = 3;
    const runLengthBits = 7;
    const maxRunLength = 1 << runLengthBits;

    function encodeRle(arr) {
      let count = 0;
      let previousValue = undefined;
      return arr.reduce((encoded, value, index) => {
        if (index === 0) {
          previousValue = value;
        }

        let addition = [];

        if (value !== previousValue || count === maxRunLength) {
          addition.push([count, previousValue]);
          count = 1;
          previousValue = value;
        } else {
          ++count;
        }

        if (index === arr.length - 1) {
          addition.push([count, previousValue]);
        }

        return [...encoded, ...addition];
      }, []);
    }

    function decodeRle(rleEncoded) {
      return rleEncoded.reduce((arr, rle) => [
        ...arr,
        ...Array(rle[0]).fill(rle[1])
      ], []);
    }

    const base64Symbols = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    function encodeToBits(value, bitCount) {
      const bits = [];
      for (let i = 0; i < bitCount; ++i) {
        bits.push((value >> (bitCount - i - 1)) & 0x1);
      }

      return bits;
    }

    function bitsToBase64Symbol(bits) {
      const value = bits.reduce(
        (value, bit, index) => value | (bit << (5 - index)),
        0
      );
      return base64Symbols[value];
    }

    function base64EncodeBits(bits) {
      let encoded = "";
      for (let currentBit = 0; currentBit < bits.length; currentBit += 6) {
        encoded += bitsToBase64Symbol(bits.slice(currentBit, currentBit + 6));
      }

      return encoded;
    }

    function base64EncodeBoard(board) {
      const bits = [
        ...encodeToBits(board.width, 6),
        ...encodeToBits(board.height, 6),
      ];

      const rleEncodedTiles = encodeRle(board.tiles);
      for (const [runLength, tile] of rleEncodedTiles) {
        bits.push(...encodeToBits(runLength, runLengthBits));
        bits.push(...encodeToBits(tile, tileBits));
      }

      return base64EncodeBits(bits);
    }

    function base64SymbolToBits(symbol) {
      const index = base64Symbols.indexOf(symbol);
      return [
        (index >> 5) & 0x1,
        (index >> 4) & 0x1,
        (index >> 3) & 0x1,
        (index >> 2) & 0x1,
        (index >> 1) & 0x1,
        index & 0x1,
      ];
    }

    function decodeBase64ToBits(encoded) {
      const bits = [];
      for (const chr of encoded) {
        if (!base64Symbols.includes(chr)) {
          throw new Error("Invalid base 64 string");
        }

        bits.push(...base64SymbolToBits(chr));
      }

      return bits;
    }

    function readBits(bitsArray, start, count) {
      return bitsArray.slice(start, start + count).reduce((value, bit, index) => {
        return value | (bit << (count - index - 1));
      }, 0);
    }

    function base64DecodeBoard(encoded) {
      const bits = decodeBase64ToBits(encoded);

      const width = readBits(bits, 0, 6);
      const height = readBits(bits, 6, 6);
      if (width === 0 || height === 0) {
        throw new Error("Invalid board");
      }

      const rleEncodedTiles = [];
      let currentBit = 12;
      while (currentBit + runLengthBits + tileBits < bits.length) {
        const runLength = readBits(bits, currentBit, runLengthBits);
        if (runLength === 0) {
          throw new Error("Invalid board");
        }

        const tile = readBits(bits, currentBit + runLengthBits, tileBits);
        if (!Object.values(tileNames).includes(tile)) {
          throw new Error("Invalid board");
        }

        rleEncodedTiles.push([runLength, tile]);

        currentBit += (runLengthBits + tileBits);
      }

      const tiles = decodeRle(rleEncodedTiles);
      if (tiles.length !== width * height) {
        throw new Error("Invalid board");
      }

      return {
        width,
        height,
        tiles,
      };
    }

    function updateTile(mouseEvent) {
      const tileWidth = boardElement.width / board.width;
      const tileHeight = boardElement.height / board.height;

      const tileX = Math.floor(mouseEvent.offsetX / tileWidth);
      const tileY = Math.floor(mouseEvent.offsetY / tileHeight);

      const tile = parseInt(selectedTileInput.selectedOptions[0].value);
      const originalTile = getTile(board, tileX, tileY);

      if (tile !== originalTile) {
        const originalBoard = cloneBoard(board);
        setTile(board, tileX, tileY, tile);
        generatedBoardOutput.value = base64EncodeBoard(board);
        renderBoard(boardElement, board, originalBoard);
      }
    }

    const boardElement = document.getElementById("board");
    const widthInput = document.getElementById("widthInput");
    const heightInput = document.getElementById("heightInput");
    const selectedTileInput = document.getElementById("selectedTile");
    const generatedBoardOutput = document.getElementById("generatedBoard");
    const buildButton = document.getElementById("build");
    const playButton = document.getElementById("play");
    const builderElement = document.getElementById("builder");
    const gameStateElement = document.getElementById("gameState");
    const loadedBoard = document.getElementById("loadedBoard");
    const loadBoard = document.getElementById("loadBoard");

    let board;
    let state;

    function updateUIWithBoard(board) {
      generatedBoardOutput.value = base64EncodeBoard(board);
      boardElement.width = board.width * tileSize;
      boardElement.height = board.height * tileSize;
      widthInput.value = board.width;
      heightInput.value = board.height;
      renderBoard(boardElement, board);
    }

    function recreateBoard() {
      board = newBoard(widthInput.valueAsNumber, heightInput.valueAsNumber);
      updateUIWithBoard(board);
    }

    function renderGameState(state) {
      const remaining = state.board.tiles.filter(tile => tile === tileNames.COLLECTABLE).length;
      const isAlive = state.board.tiles.some(tile => tile === tileNames.PLAYER);
      gameStateElement.textContent = `${state.collected} collected, ${remaining} remaining, ${isAlive ? "alive" : "dead"}`;
    }

    function nextCoordinateInDirection(x, y, direction) {
      let newX = x;
      let newY = y;

      switch (direction) {
        case "Up":
          --newY;
          break;

        case "Left":
          --newX;
          break;

        case "Down":
          ++newY;
          break;

        case "Right":
          ++newX;
          break;

        case "DownLeft":
          --newX;
          ++newY;
          break;

        case "DownRight":
          ++newX;
          ++newY;
          break;
      }

      return [newX, newY];
    }

    function canMoveToLocation(board, x, y, direction) {
      if (!isInBounds(board, x, y)) {
        return false;
      }

      const tile = getTile(board, x, y);
      if (tile === tileNames.WALL || tile === tileNames.DEAD_PLAYER) {
        return false;
      } else if (tile === tileNames.ROCK) {
        const [nextX, nextY] = nextCoordinateInDirection(x, y, direction);
        if (!isInBounds(board, nextX, nextY)) {
          return false;
        }

        const nextTile = getTile(board, nextX, nextY);
        if (nextTile !== tileNames.EMPTY && nextTile !== tileNames.DIRT) {
          return false;
        }
      }

      return true;
    }

    function movePlayer(state, direction) {
      const playerIndex = state.board.tiles.findIndex(tile => tile === tileNames.PLAYER);

      const playerX = playerIndex % state.board.width;
      const playerY = Math.floor(playerIndex / state.board.width);
      const [newX, newY] = nextCoordinateInDirection(playerX, playerY, direction);

      if (canMoveToLocation(state.board, newX, newY, direction)) {
        const tile = getTile(state.board, newX, newY);
        if (tile === tileNames.COLLECTABLE) {
          ++state.collected;
        }

        setTile(state.board, playerX, playerY, tileNames.EMPTY);
        setTile(state.board, newX, newY, tileNames.PLAYER);

        if (tile === tileNames.ROCK) {
          const [nextX, nextY] = nextCoordinateInDirection(newX, newY, direction);
          setTile(state.board, nextX, nextY, tileNames.ROCK);
        }
      }
    }

    function canFallDown(state, x, y) {
      if (y === state.board.height - 1) {
        return false;
      }

      const isTileBelowFalling = state.fallingRocks.find(
        ([tileX, tileY]) => tileX === x && tileY === y + 1
      );

      const tileBelow = getTile(state.board, x, y + 1);
      return tileBelow === tileNames.EMPTY ||
        tileBelow === tileNames.PLAYER ||
        isTileBelowFalling;
    }

    function canFallLeft(state, x, y) {
      if (y === state.board.height - 1 || x === 0 || canFallDown(state, x, y)) {
        return false;
      }

      const tileBelow = getTile(state.board, x, y + 1);
      const tileLeft = getTile(state.board, x - 1, y);
      const tileBelowLeft = getTile(state.board, x - 1, y + 1);
      return tileBelow === tileNames.ROCK &&
        tileLeft === tileNames.EMPTY &&
        (tileBelowLeft === tileNames.EMPTY || tileBelowLeft === tileNames.PLAYER);
    }

    function canFallRight(state, x, y) {
      if (
        y === state.board.height - 1 ||
        x === state.board.width - 1 ||
        canFallDown(state, x, y)
      ) {
        return false;
      }

      const tileBelow = getTile(state.board, x, y + 1);
      const tileRight = getTile(state.board, x + 1, y);
      const tileBelowRight = getTile(state.board, x + 1, y + 1);
      return tileBelow === tileNames.ROCK &&
        tileRight === tileNames.EMPTY &&
        (tileBelowRight === tileNames.EMPTY || tileBelowRight === tileNames.PLAYER);
    }

    function updateFallingRocks(state) {
      for (let x = 0; x < state.board.width; ++x) {
        // Skip the last row since rocks on the last row can't fall
        // Always add the rocks from bottom to top so that a rock falling from
        // below triggers the rocks above to fall
        for (let y = state.board.height - 2; y >= 0; --y) {
          const tile = getTile(state.board, x, y);
          const tileBelow = getTile(state.board, x, y + 1);
          if (tile === tileNames.ROCK && tileBelow !== tileNames.PLAYER && canFallDown(state, x, y)) {
            state.fallingRocks.push([x, y, "Down"]);
          }
        }
      }
    }

    function applyGravityToFallingRocks(state) {
      const fallingRocks = state.fallingRocks;
      state.fallingRocks = [];

      // Since state.fallingRocks is ordered bottom to top this loop keeps the
      // same order
      for (const [x, y, direction] of fallingRocks) {
        const [newX, newY, newDirection] = applyGravityToRock(state, x, y, direction);
        if (newDirection !== "None") {
          state.fallingRocks.push([newX, newY, newDirection]);
        }
      }
    }

    function applyGravityToRock(state, x, y, direction) {
      const [newX, newY] = nextCoordinateInDirection(x, y, direction);

      // Prevent this rock from falling if another rock has taken up that space
      const tile = getTile(state.board, newX, newY);
      if (tile !== tileNames.EMPTY && tile !== tileNames.PLAYER) {
        return [x, y, "None"];
      }

      if (tile === tileNames.PLAYER) {
        setTile(state.board, newX, newY, tileNames.DEAD_PLAYER);
        return [x, y, "None"];
      }

      setTile(state.board, x, y, tileNames.EMPTY);
      setTile(state.board, newX, newY, tileNames.ROCK);

      if (canFallDown(state, newX, newY)) {
        return [newX, newY, "Down"];
      } else if (canFallLeft(state, newX, newY)) {
        return [newX, newY, "DownLeft"];
      } else if (canFallRight(state, newX, newY)) {
        return [newX, newY, "DownRight"];
      }

      return [newX, newY, "None"];
    }

    function handleInput(keyboardEvent) {
      if (state.fallingRocks.length > 0) {
        return;
      }

      const originalBoard = cloneBoard(state.board);

      let handled = true;
      switch (keyboardEvent.key) {
        case "Up":
        case "ArrowUp":
        case "w":
          movePlayer(state, "Up");
          break;

        case "Left":
        case "ArrowLeft":
        case "a":
          movePlayer(state, "Left");
          break;

        case "Down":
        case "ArrowDown":
        case "s":
          movePlayer(state, "Down");
          break;

        case "Right":
        case "ArrowRight":
        case "d":
          movePlayer(state, "Right");
          break;

        default:
          handled = false;
      }

      if (handled) {
        updateFallingRocks(state);
        renderBoard(boardElement, state.board, originalBoard);
        renderGameState(state);
        keyboardEvent.preventDefault(); // Prevent other browser behaviors
      }
    }

    widthInput.addEventListener("change", recreateBoard);
    heightInput.addEventListener("change", recreateBoard);

    let isDragDrawing = false;
    function enableDragDrawing() {
      isDragDrawing = true;
    }

    function disableDragDrawing() {
      isDragDrawing = false;
    }

    function updateDraggedTiles(mouseEvent) {
      if (isDragDrawing) {
        updateTile(mouseEvent);
      }
    }

    let timerId;
    buildButton.addEventListener("click", () => {
      buildButton.disabled = true;
      playButton.disabled = false;
      builderElement.hidden = false;
      gameStateElement.hidden = true;

      document.removeEventListener("keydown", handleInput);

      boardElement.addEventListener("mousedown", enableDragDrawing);
      document.addEventListener("mouseup", disableDragDrawing);
      boardElement.addEventListener("mousemove", updateDraggedTiles);
      boardElement.addEventListener("click", updateTile);

      clearInterval(timerId);

      renderBoard(boardElement, board);
    });

    playButton.addEventListener("click", () => {
      buildButton.disabled = false;
      playButton.disabled = true;
      builderElement.hidden = true;
      gameStateElement.hidden = false;
      playButton.blur(); // Returns focus to the document

      state = newGameState(board);
      updateFallingRocks(state);
      renderGameState(state);

      document.addEventListener("keydown", handleInput);

      boardElement.removeEventListener("mousedown", enableDragDrawing);
      document.removeEventListener("mouseup", disableDragDrawing);
      boardElement.removeEventListener("mousemove", updateDraggedTiles);
      boardElement.removeEventListener("click", updateTile);

      timerId = setInterval(
        () => {
          if (state.fallingRocks.length > 0) {
            const originalBoard = cloneBoard(state.board);
            applyGravityToFallingRocks(state);
            renderBoard(boardElement, state.board, originalBoard);
            renderGameState(state);
          }
        },
        tickMs
      );

      renderBoard(boardElement, board);
    });

    loadBoard.addEventListener("click", () => {
      const encoded = loadedBoard.value.trim();
      try {
        board = base64DecodeBoard(loadedBoard.value.trim());
        updateUIWithBoard(board);
      } catch (e) {
        console.log(e);
      }
    });

    recreateBoard();

    tiles.addEventListener("load", () => {
      buildButton.click();
      recreateBoard();
    });
    tiles.src = "assets/tiles.svg";
  </script>
</html>
