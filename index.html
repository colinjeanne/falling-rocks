<!doctype html>
<html>
  <head>
    <title>Rocks</title>
    <meta charset="utf-8">
  </head>
  <body>
    <div>
      <div>
        <button id="build" type="button">Build</button>
        <button id="play" type="button">Play</button>
      </div>
      <canvas id="board" width="640" height="640"></canvas>
      <div id="builder">
        <div>
          <label for="widthInput">Width</label>
          <input id="widthInput" type="number" min="1" value="10">
        </div>
        <div>
          <label for="heightInput">Height</label>
          <input id="heightInput" type="number" min="1" value="10">
        </div>
        <div>
          <select id="selectedTile">
            <option value="0" selected>Black</option>
            <option value="1">Red</option>
            <option value="2">Green</option>
            <option value="3">Blue</option>
            <option value="4">Yellow</option>
          </select>
        </div>
        <div>
          <output id="generatedBoard"></output>
        </div>
      </div>
    </div>
  </body>
  <script type="module">
    const tiles = new Image();

    const tileNames = {
      EMPTY: 0,
      WALL: 1,
      PLAYER: 4,
    };

    function drawTile(context, tile, x, y, width, height) {
      context.save();

      context.drawImage(
        tiles,
        0,
        tiles.naturalWidth * tile,
        tiles.naturalWidth,
        tiles.naturalWidth,
        x,
        y,
        width,
        height
      );

      context.restore();
    }

    function renderBoard(canvas, board, originalBoard) {
      const context = canvas.getContext("2d");

      const tileWidth = canvas.width / board.width;
      const tileHeight = canvas.height / board.height;

      const areBoardsCompatible =
        board.width === originalBoard?.width &&
        board.height === originalBoard?.height;

      board.tiles.forEach((tile, index) => {
        if (areBoardsCompatible && tile === originalBoard.tiles[index]) {
          return;
        }

        const tileX = index % board.width;
        const tileY = Math.floor(index / board.width);

        drawTile(context, tile, tileX * tileWidth, tileY * tileHeight, tileWidth, tileHeight);
      });
    }

    function newBoard(width, height) {
      return {
        width,
        height,
        tiles: Array(width * height).fill(0, 0),
      };
    }

    function validateCoordinate(board, x, y) {
      if (x < 0 || x >= board.width || y < 0 || y >= board.height) {
        throw new Error("Coordinate out of bounds");
      }
    }

    function getTile(board, x, y) {
      validateCoordinate(board, x, y);
      return board.tiles[x + y * board.width];
    }

    function setTile(board, x, y, tile) {
      validateCoordinate(board, x, y);
      board.tiles[x + y * board.width] = tile;
    }

    function cloneBoard(board) {
      return {
        width: board.width,
        height: board.height,
        tiles: board.tiles.slice(),
      };
    }

    function rle(arr) {
      let count = 0;
      let previousValue = undefined;
      return arr.reduce((encoded, value, index) => {
        if (index === 0) {
          previousValue = value;
        }

        let addition = "";

        if (value !== previousValue) {
          addition = `.${(count << 3) | previousValue}`;
          count = 1;
          previousValue = value;
        } else {
          ++count;
        }

        if (index === arr.length - 1) {
          addition += `.${(count << 3) | previousValue}`;
        }

        return encoded + addition;
      }, "");
    }

    function boardToString(board) {
      return `${board.width}.${board.height}${rle(board.tiles)}`;
    }

    function updateTile(mouseEvent) {
      const tileWidth = boardElement.width / board.width;
      const tileHeight = boardElement.height / board.height;

      const tileX = Math.floor(mouseEvent.offsetX / tileWidth);
      const tileY = Math.floor(mouseEvent.offsetY / tileHeight);

      const tile = parseInt(selectedTileInput.selectedOptions[0].value);
      const originalTile = getTile(board, tileX, tileY);

      if (tile !== originalTile) {
        const originalBoard = cloneBoard(board);
        setTile(board, tileX, tileY, tile);
        generatedBoardOutput.value = boardToString(board);
        renderBoard(boardElement, board, originalBoard);
      }
    }

    const boardElement = document.getElementById("board");
    const widthInput = document.getElementById("widthInput");
    const heightInput = document.getElementById("heightInput");
    const selectedTileInput = document.getElementById("selectedTile");
    const generatedBoardOutput = document.getElementById("generatedBoard");
    const buildButton = document.getElementById("build");
    const playButton = document.getElementById("play");
    const builderElement = document.getElementById("builder");

    let board;
    function recreateBoard() {
      board = newBoard(widthInput.valueAsNumber, heightInput.valueAsNumber);
      generatedBoardOutput.value = boardToString(board);
      boardElement.width = board.width * 32;
      boardElement.height = board.height * 32;
      renderBoard(boardElement, board);
    }

    function canMoveToLocation(board, x, y) {
      return (x >= 0) &&
        (x <= board.width - 1) &&
        (y >= 0) &&
        (y <= board.height - 1) &&
        (getTile(board, x, y) !== tileNames.WALL);
    }

    function movePlayer(board, direction) {
      const playerIndex = board.tiles.findIndex(tile => tile === tileNames.PLAYER);

      const playerX = playerIndex % board.width;
      const playerY = Math.floor(playerIndex / board.width);

      let newX = playerX;
      let newY = playerY;

      switch (direction) {
        case "Up":
          --newY;
          break;

        case "Left":
          --newX;
          break;

        case "Down":
          ++newY;
          break;

        case "Right":
          ++newX;
          break;
      }

      if (canMoveToLocation(board, newX, newY)) {
        const originalBoard = cloneBoard(board);
        setTile(board, playerX, playerY, tileNames.EMPTY);
        setTile(board, newX, newY, tileNames.PLAYER);
        renderBoard(boardElement, board, originalBoard);
      }
    }

    function handleInput(keyboardEvent) {
      let handled = true;
      switch (keyboardEvent.key) {
        case "Up":
        case "ArrowUp":
        case "w":
          movePlayer(board, "Up");
          break;

        case "Left":
        case "ArrowLeft":
        case "a":
          movePlayer(board, "Left");
          break;

        case "Down":
        case "ArrowDown":
        case "s":
          movePlayer(board, "Down");
          break;

        case "Right":
        case "ArrowRight":
        case "d":
          movePlayer(board, "Right");
          break;

        default:
          handled = false;
      }

      if (handled) {
        keyboardEvent.preventDefault(); // Prevent other browser behaviors
      }
    }

    widthInput.addEventListener("change", recreateBoard);
    heightInput.addEventListener("change", recreateBoard);

    let isDragDrawing = false;
    function enableDragDrawing() {
      isDragDrawing = true;
    }

    function disableDragDrawing() {
      isDragDrawing = false;
    }

    function updateDraggedTiles(mouseEvent) {
      if (isDragDrawing) {
        updateTile(mouseEvent);
      }
    }

    buildButton.addEventListener("click", () => {
      buildButton.disabled = true;
      playButton.disabled = false;
      builderElement.hidden = false;

      document.removeEventListener("keydown", handleInput);

      boardElement.addEventListener("mousedown", enableDragDrawing);
      document.addEventListener("mouseup", disableDragDrawing);
      boardElement.addEventListener("mousemove", updateDraggedTiles);
      boardElement.addEventListener("click", updateTile);
    });

    playButton.addEventListener("click", () => {
      buildButton.disabled = false;
      playButton.disabled = true;
      builderElement.hidden = true;
      playButton.blur(); // Returns focus to the document

      document.addEventListener("keydown", handleInput);

      boardElement.removeEventListener("mousedown", enableDragDrawing);
      document.removeEventListener("mouseup", disableDragDrawing);
      boardElement.removeEventListener("mousemove", updateDraggedTiles);
      boardElement.removeEventListener("click", updateTile);
    });

    tiles.addEventListener("load", () => {
      buildButton.click();
      recreateBoard();
    });
    tiles.src = "assets/tiles.svg";
  </script>
</html>
